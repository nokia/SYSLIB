/**
 *   @file  netfp_mgmt.c
 *
 *   @brief
 *      NETFP Event Management Layer. NETFP Events are generated by the
 *      NETFP server and are propogated across all the registered NETFP
 *      clients.
 *
 *  \par
 *  NOTE:
 *      (C) Copyright 2013-2014 Texas Instruments, Inc.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**************************************************************************
 *************************** Include Files ********************************
 **************************************************************************/

/* Standard Include Files. */
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

/* SYSLIB Include Files. */
#include <ti/runtime/netfp/netfp.h>
#include <ti/runtime/netfp/include/netfp_internal.h>

/* For Debugging only. */
#ifdef __ARMv7
#include <ti/apps/netfp_config/include/NetFP_System_printf.h> //fzm
#else
#include <xdc/runtime/System.h>
#endif

/**************************************************************************
 *********************** NETFP Mgmt Functions *****************************
 **************************************************************************/

/**
 *  @b Description
 *  @n
 *      The function is used to allocate memory for the event meta information
 *
 *  @param[in]  ptrNetfpServer
 *      Pointer to the NETFP Server
 *  @param[in]  clientIndex
 *      Index of the NETFP client for which memory is to be allocated
 *
 * \ingroup NETFP_INTERNAL_FUNCTION
 *
 *  @retval
 *      Success -   0
 *  @retval
 *      Error   -   <0
 */
static Netfp_EventMetaInfo* Netfp_allocEventMetaInfo
(
    Netfp_ServerMCB*    ptrNetfpServer,
    int32_t             clientIndex
)
{
    return (Netfp_EventMetaInfo*)ptrNetfpServer->cfg.malloc (sizeof(Netfp_EventMetaInfo), 0);
}

/**
 *  @b Description
 *  @n
 *      The function is used to free memory for the event meta information
 *
 *  @param[in]  ptrNetfpServer
 *      Pointer to the NETFP Server
 *  @param[in]  clientIndex
 *      Index of the NETFP client for which memory is to be cleaned up
 *  @param[in]  ptrEventMetaInfo
 *      Pointer to the event meta information
 *
 * \ingroup NETFP_INTERNAL_FUNCTION
 *
 *  @retval
 *      Success -   0
 *  @retval
 *      Error   -   <0
 */
static void Netfp_freeEventMetaInfo
(
    Netfp_ServerMCB*        ptrNetfpServer,
    int32_t                 clientIndex,
    Netfp_EventMetaInfo*    ptrEventMetaInfo
)
{
    ptrNetfpServer->cfg.free (ptrEventMetaInfo, sizeof(Netfp_EventMetaInfo));
}

/**
 *  @b Description
 *  @n
 *      The function is invoked on the NETFP client to process the event which has been generated
 *      on the NETFP Server.
 *
 *  @param[in]  clientHandle
 *      Handle of the NETFP Client
 *  @param[in]  ptrEventMetaInfo
 *      Event meta information associated with the event.
 *
 * \ingroup NETFP_INTERNAL_FUNCTION
 *
 *  @retval
 *      Not applicable
 */
static void _Netfp_processEvent
(
    Netfp_ClientHandle      clientHandle,
    Netfp_EventMetaInfo*    ptrEventMetaInfo
)
{
    Netfp_ClientMCB*    ptrNetfpClient;

    /* Get the NETFP Client: */
    ptrNetfpClient = (Netfp_ClientMCB*)clientHandle;
    if (ptrNetfpClient == NULL)
        return;

    /* Invoke the event handler for each handled event: */
    switch (ptrEventMetaInfo->eventId)
    {
        case Netfp_EventId_DELETE_FP:
        {
            Netfp_socketDeleteFastPathHandler (ptrNetfpClient, ptrEventMetaInfo);
            break;
        }
        case Netfp_EventId_UPDATE_INTERFACE:
        {
            Netfp_socketUpdateInterfaceHandler (ptrNetfpClient, ptrEventMetaInfo);
            break;
        }
        case Netfp_EventId_UPDATE_FP:
        {
            Netfp_socketUpdateFastPathHandler (ptrNetfpClient, ptrEventMetaInfo);
            break;
        }
        case Netfp_EventId_ADD_SW_OFFLOAD_SA:
        {
            if(ptrNetfpClient->addSaEventHandler)
                ptrNetfpClient->addSaEventHandler(ptrEventMetaInfo);

            break;
        }
        case Netfp_EventId_DEL_SW_OFFLOAD_SA:
        {
            if(ptrNetfpClient->delSaEventHandler)
                ptrNetfpClient->delSaEventHandler(ptrEventMetaInfo);

            break;
        }
        default:
        {
            /* FATAL Error: There should be no other event which is generated. */
            System_printf ("Error: Event %d is NOT handled in the client '%s'\n",
                           ptrEventMetaInfo->eventId, ptrNetfpClient->cfg.clientName);
            break;
        }
    }
    return;
}

/**
 *  @b Description
 *  @n
 *      The function is used to generate an event. Events can be generated by various submodules
 *      within NETFP due to certain configuration changes. Once an event is generated it is
 *      replicated to all the NETFP clients within this function.
 *
 *  @param[in]  ptrNetfpServer
 *      Pointer to the NETFP Server
 *  @param[in]  ptrEventInfo
 *      Pointer to the event meta information associated with the event.
 *
 * \ingroup NETFP_INTERNAL_FUNCTION
 *
 *  @retval
 *      Not applicable
 */
void Netfp_generateEvent
(
    Netfp_ServerMCB*        ptrNetfpServer,
    Netfp_EventMetaInfo*    ptrEventInfo
)
{
    int32_t                 clientIndex;
    Netfp_EventMetaInfo*    ptrEventMetaInfo;
    Netfp_ClientBlock*      ptrClientBlock;

    /* Cycle through all the NETFP clients. */
    for (clientIndex = 0; clientIndex < NETFP_MAX_CLIENTS; clientIndex++)
    {
        /* Is the client active? */
        if (ptrNetfpServer->clientBlock[clientIndex].status != Netfp_ClientStatus_ACTIVE)
            continue;

        /* Get the client block */
        ptrClientBlock = &ptrNetfpServer->clientBlock[clientIndex];

        /* Skip the PROXY Client: Proxy clients are not interested in the NETFP events. */
        if (ptrNetfpServer->proxyClientBlock == ptrClientBlock)
            continue;

//fzm-->
        /* Skip sending Netfp_EventId_ADD_SW_OFFLOAD_SA to not registered client */
        if (ptrEventInfo->eventId == Netfp_EventId_ADD_SW_OFFLOAD_SA && (ptrClientBlock->clientHandle != ptrNetfpServer->swLutInfo.initSwLut.client))
            continue;
//fzm<--

        /* Client was operational: Allocate event meta information */
        ptrEventMetaInfo = Netfp_allocEventMetaInfo (ptrNetfpServer, clientIndex);
        if (ptrEventMetaInfo == NULL)
        {
            /* Error: Client event meta information could not be be allocated. This is not good
             * because the NETFP client will now no longer be in SYNC with the rest of the system.
             * This could happen if the client is not active any more. Record the error and continue
             * with the rest of the clients. */
            Netfp_logMsg (ptrNetfpServer, Netfp_LogLevel_ERROR, "Error: Event %d dropped for client name %s\n",
                          ptrEventInfo->eventId, ptrClientBlock->name);
            continue;
        }

        /* Copy over the meta information. */
        memcpy ((void *)ptrEventMetaInfo, (void *)ptrEventInfo, sizeof(Netfp_EventMetaInfo));

        /* Place the meta information into the client dispatch list. */
        Netfp_listAdd ((Netfp_ListNode**)&ptrNetfpServer->clientBlock[clientIndex].eventDispatchList, (Netfp_ListNode*)ptrEventMetaInfo);
    }
    return;
}

/**
 *  @b Description
 *  @n
 *      The function is the main event management loop which is responsible for dispatching
 *      the events to each NETFP clients and is also responsible for processing the responses
 *      dispatched and cleans them.
 *
 *  @param[in]  ptrNetfpServer
 *      Pointer to the NETFP Server
 *
 * \ingroup NETFP_INTERNAL_FUNCTION
 *
 *  @retval
 *      Number of events processed.
 */
int32_t Netfp_processEvents (Netfp_ServerMCB* ptrNetfpServer)
{
    int32_t                 clientIndex;
    Netfp_EventMetaInfo*    ptrEventMetaInfo;
    Josh_Argument           args[JOSH_MAX_ARGS];
    Josh_JobHandle          jobHandle;
    Josh_ArgHandle          argHandle;
    int32_t                 errCode;
    Netfp_EventMetaInfo*    ptrRemoteEventMetaInfo;
    Netfp_ClientBlock*      ptrClientBlock;
    int32_t                 numEventsProcessed = 0;

    /***************************************************************************************
     * Cycle through the events in the dispatch list and send them across to each
     * NETFP client.
     ***************************************************************************************/
    for (clientIndex = 0; clientIndex < NETFP_MAX_CLIENTS; clientIndex++)
    {
        /* Is the client operational? */
        if (ptrNetfpServer->clientBlock[clientIndex].status != Netfp_ClientStatus_ACTIVE)
            continue;

        /* Get the handle to the NETFP client block. */
        ptrClientBlock = &ptrNetfpServer->clientBlock[clientIndex];

        /* Client was operational: Cycle through and dispatch all the events which need to be dispatched. */
        while (1)
        {
            /* Is there an event to be dispatched? */
            ptrEventMetaInfo = (Netfp_EventMetaInfo*)Netfp_listRemove((Netfp_ListNode**)&ptrClientBlock->eventDispatchList);
            if (ptrEventMetaInfo == NULL)
                break;

            /* Get the actual job which we will execute */
            jobHandle = Josh_findJobByAddress(ptrClientBlock->joshHandle, (Josh_JobProtype)_Netfp_processEvent);
            if (jobHandle == NULL)
            {
                Netfp_logMsg (ptrNetfpServer, Netfp_LogLevel_ERROR, "FATAL Internal Error: Unable to find the internal processEvent job.\n");
                return 0;
            }

            /* Initialize the arguments; to avoid any junk */
            memset ((void *)&args, 0, sizeof(args));

            /***************************************************************************
             * This is the function which is to be invoked:
             *
             *  void _Netfp_processEvent
             *  (
             *  Netfp_ClientHandle      clientHandle,
             *  Netfp_EventMetaInfo*    ptrEventMetaInfo
             *  )
             ****************************************************************************/

            /* Populate the arguments.
             * - Argument 1: */
            args[0].type   = Josh_ArgumentType_PASS_BY_VALUE;
            args[0].length = sizeof(Netfp_ClientHandle);

            /*  - Argument 2: */
            args[1].type   = Josh_ArgumentType_PASS_BY_REF;
            args[1].length = sizeof(Netfp_EventMetaInfo);

            /* Add the arguments. */
            argHandle = Josh_addArguments (ptrClientBlock->joshHandle, &args[0]);
            if (argHandle == NULL)
            {
                /* Error: Unable to add the arguments implies that all the JOSH jobs have been exhausted. We need
                 * to implement a retry logic here. Log the warning this is more for debugging. */
                Netfp_logMsg (ptrNetfpServer, Netfp_LogLevel_DEBUG, "Warning: Retrying Event 0x%x [%d]\n", ptrEventMetaInfo, numEventsProcessed);

                /* Add the event back to the dispatch list. */
                Netfp_listCat ((Netfp_ListNode**)&ptrEventMetaInfo, (Netfp_ListNode**)&ptrClientBlock->eventDispatchList);
                ptrClientBlock->eventDispatchList = ptrEventMetaInfo;
                return numEventsProcessed;
            }

            /* Populate the NETFP Client handle */
            *(uint32_t*)args[0].argBuffer = (uint32_t)josh_toRemoteU32(ptrClientBlock->clientHandle);

            /* Get the pointer to the interface configuration. */
            ptrRemoteEventMetaInfo = (Netfp_EventMetaInfo*)args[1].argBuffer;
            memcpy ((void*)ptrRemoteEventMetaInfo, (void *)ptrEventMetaInfo, sizeof (Netfp_EventMetaInfo));

            /* Submit the JOB to JOSH for asynchronous execution. */
            int32_t jobId = Josh_submitAsyncJob(jobHandle, argHandle, &errCode);
            if(jobId < 0)
            {
                if(errCode == JOSH_EBUSY)
                {
                    Netfp_logMsg (ptrNetfpServer, Netfp_LogLevel_DEBUG, "Warning: Josh transport busy, retrying Event 0x%x [%d]\n", ptrEventMetaInfo, numEventsProcessed);

                    Netfp_listCat ((Netfp_ListNode**)&ptrEventMetaInfo, (Netfp_ListNode**)&ptrClientBlock->eventDispatchList);
                    ptrClientBlock->eventDispatchList = ptrEventMetaInfo;
                }
                else
                {
                    Netfp_logMsg (ptrNetfpServer, Netfp_LogLevel_ERROR, "Error: JOSH Submit ASYNC Job failed [Error code %d]\n", errCode);

                    Netfp_freeEventMetaInfo (ptrNetfpServer, clientIndex, ptrEventMetaInfo);
                }

                uint32_t jobInstanceId = Josh_getJobInstanceId(argHandle);
                Josh_freeJobInstance(ptrClientBlock->joshHandle, jobInstanceId);

                break;
            }

            Josh_freeJobInstance(ptrClientBlock->joshHandle, jobId);
            Netfp_freeEventMetaInfo (ptrNetfpServer, clientIndex, ptrEventMetaInfo);

            /* Keep track of the number of events which have been processed. */
            numEventsProcessed++;
        }
    }

    return numEventsProcessed;
}

/**
 *  @b Description
 *  @n
 *      The function is used to initialize the NETFP Event Management layer
 *      which is done for each NETFP client in the system.
 *
 *  @param[in]  ptrNetfpServer
 *      Pointer to the NETFP Server
 *  @param[in]  clientIndex
 *      NETFP Client index which is to be registered
 *  @param[out] errCode
 *      Error code populated on error.
 *
 * \ingroup NETFP_INTERNAL_FUNCTION
 *
 *  @retval
 *      Success -   0
 *  @retval
 *      Error   -   <0
 */
int32_t Netfp_initClientEventMgmt
(
    Netfp_ServerMCB*    ptrNetfpServer,
    int32_t             clientIndex,
    int32_t*            errCode
)
{
    /* Initialize the event list for the NETFP client. */
    ptrNetfpServer->clientBlock[clientIndex].eventDispatchList   = NULL;
    ptrNetfpServer->clientBlock[clientIndex].eventDispatchedList = NULL;
    return 0;
}

/**
 *  @b Description
 *  @n
 *      The function is used to deregister the NETFP event management services for a specific
 *      NETFP client.
 *
 *  @param[in]  ptrNetfpServer
 *      Pointer to the NETFP Server
 *  @param[in]  clientIndex
 *      NETFP Client index which is to be registered
 *  @param[out] errCode
 *      Error code populated on error.
 *
 * \ingroup NETFP_INTERNAL_FUNCTION
 *
 *  @retval
 *      Success -   0
 *  @retval
 *      Error   -   <0
 */
int32_t Netfp_deinitClientEventMgmt
(
    Netfp_ServerMCB*    ptrNetfpServer,
    int32_t             clientIndex,
    int32_t*            errCode
)
{
    Netfp_EventMetaInfo*    ptrEventMetaInfo;

    /* Ensure that there are no events which are in the dispatch or dispatched list. */
    ptrEventMetaInfo = (Netfp_EventMetaInfo*)Netfp_listGetHead ((Netfp_ListNode**)&ptrNetfpServer->clientBlock[clientIndex].eventDispatchList);
    if (ptrEventMetaInfo != NULL)
    {
        *errCode = NETFP_ENOTREADY;
        return -1;
    }
    ptrEventMetaInfo = (Netfp_EventMetaInfo*)Netfp_listGetHead ((Netfp_ListNode**)&ptrNetfpServer->clientBlock[clientIndex].eventDispatchedList);
    if (ptrEventMetaInfo != NULL)
    {
        *errCode = NETFP_ENOTREADY;
        return -1;
    }
    return 0;
}

/**
 *  @b Description
 *  @n
 *      The function is used to register the JOSH services for the event management
 *      module.
 *
 *  @param[in]  nodeHandle
 *      JOSH node handle to which the event management services are being registered
 *
 * \ingroup NETFP_INTERNAL_FUNCTION
 *
 *  @retval
 *      Success -   0
 *  @retval
 *      Error   -   <0
 */
int32_t Netfp_registerEventMgmtServices(Josh_NodeHandle nodeHandle)
{
    Josh_registerJob(nodeHandle, (Josh_JobProtype)_Netfp_processEvent);
    return 0;
}

